'use strict';

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

let runTests = (() => {
    var _ref = (0, _asyncToGenerator3.default)(function* (argParser) {
        const opts = argParser.opts;
        const port1 = opts.ports && opts.ports[0];
        const port2 = opts.ports && opts.ports[1];
        const proxy = opts.proxy;
        const proxyBypass = opts.proxyBypass;

        _log2.default.showSpinner();

        const testCafe = yield (0, _2.default)(opts.hostname, port1, port2, opts.ssl, opts.dev);
        const remoteBrowsers = yield (0, _remotesWizard2.default)(testCafe, argParser.remoteCount, opts.qrCode);
        const browsers = argParser.browsers.concat(remoteBrowsers);
        const runner = opts.live ? testCafe.createLiveModeRunner() : testCafe.createRunner();

        let failed = 0;

        runner.isCli = true;

        runner.useProxy(proxy, proxyBypass).src(argParser.src).browsers(browsers).reporter(argParser.opts.reporter).concurrency(argParser.opts.concurrency).filter(argParser.filter).video(opts.video, opts.videoOptions, opts.videoEncodingOptions).screenshots(opts.screenshots, opts.screenshotsOnFails, opts.screenshotPathPattern).startApp(opts.app, opts.appInitDelay);

        runner.once('done-bootstrapping', function () {
            return _log2.default.hideSpinner();
        });

        try {
            failed = yield runner.run(opts);
        } finally {
            showMessageOnExit = false;
            yield testCafe.close();
        }

        exit(failed);
    });

    return function runTests(_x) {
        return _ref.apply(this, arguments);
    };
})();

let listBrowsers = (() => {
    var _ref2 = (0, _asyncToGenerator3.default)(function* (providerName = 'locally-installed') {
        // NOTE: Load the provider pool lazily to reduce startup time
        const browserProviderPool = require('../browser/provider/pool');

        const provider = yield browserProviderPool.getProvider(providerName);

        if (!provider) throw new _runtime.GeneralError(_message2.default.browserProviderNotFound, providerName);

        if (provider.isMultiBrowser) {
            const browserNames = yield provider.getBrowserList();

            yield browserProviderPool.dispose();

            if (providerName === 'locally-installed') console.log(browserNames.join('\n'));else console.log(browserNames.map(function (browserName) {
                return `"${providerName}:${browserName}"`;
            }).join('\n'));
        } else console.log(`"${providerName}"`);

        exit(0);
    });

    return function listBrowsers() {
        return _ref2.apply(this, arguments);
    };
})();

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _runtime = require('../errors/runtime');

var _message = require('../errors/runtime/message');

var _message2 = _interopRequireDefault(_message);

var _argumentParser = require('./argument-parser');

var _argumentParser2 = _interopRequireDefault(_argumentParser);

var _terminationHandler = require('./termination-handler');

var _terminationHandler2 = _interopRequireDefault(_terminationHandler);

var _log = require('./log');

var _log2 = _interopRequireDefault(_log);

var _remotesWizard = require('./remotes-wizard');

var _remotesWizard2 = _interopRequireDefault(_remotesWizard);

var _ = require('../');

var _2 = _interopRequireDefault(_);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let showMessageOnExit = true;
let exitMessageShown = false;
let exiting = false;

function exitHandler(terminationLevel) {
    if (showMessageOnExit && !exitMessageShown) {
        exitMessageShown = true;

        _log2.default.write('Stopping TestCafe...');

        process.on('exit', () => _log2.default.hideSpinner(true));
    }

    if (exiting || terminationLevel < 2) return;

    exiting = true;

    exit(0);
}

function exit(code) {
    _log2.default.hideSpinner(true);

    // NOTE: give a process time to flush the output.
    // It's necessary in some environments.
    setTimeout(() => process.exit(code), 0);
}

function error(err) {
    _log2.default.hideSpinner();

    let message = null;

    // HACK: workaround for the `instanceof` problem
    // (see: http://stackoverflow.com/questions/33870684/why-doesnt-instanceof-work-on-instances-of-error-subclasses-under-babel-node)
    if (err.constructor === _runtime.GeneralError) message = err.message;else if (err.constructor === _runtime.APIError) message = err.coloredStack;else message = err.stack;

    _log2.default.write(_chalk2.default.red('ERROR ') + message + '\n');
    _log2.default.write(_chalk2.default.gray('Type "testcafe -h" for help.'));

    exit(1);
}

(() => {
    var _ref3 = (0, _asyncToGenerator3.default)(function* () {
        const terminationHandler = new _terminationHandler2.default();

        terminationHandler.on(_terminationHandler2.default.TERMINATION_LEVEL_INCREASED_EVENT, exitHandler);

        try {
            const argParser = new _argumentParser2.default();

            yield argParser.parse(process.argv);

            if (argParser.opts.listBrowsers) yield listBrowsers(argParser.opts.providerName);else yield runTests(argParser);
        } catch (err) {
            showMessageOnExit = false;
            error(err);
        }
    });

    function cli() {
        return _ref3.apply(this, arguments);
    }

    return cli;
})()();
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbGkvY2xpLmpzIl0sIm5hbWVzIjpbImFyZ1BhcnNlciIsIm9wdHMiLCJwb3J0MSIsInBvcnRzIiwicG9ydDIiLCJwcm94eSIsInByb3h5QnlwYXNzIiwibG9nIiwic2hvd1NwaW5uZXIiLCJ0ZXN0Q2FmZSIsImhvc3RuYW1lIiwic3NsIiwiZGV2IiwicmVtb3RlQnJvd3NlcnMiLCJyZW1vdGVDb3VudCIsInFyQ29kZSIsImJyb3dzZXJzIiwiY29uY2F0IiwicnVubmVyIiwibGl2ZSIsImNyZWF0ZUxpdmVNb2RlUnVubmVyIiwiY3JlYXRlUnVubmVyIiwiZmFpbGVkIiwiaXNDbGkiLCJ1c2VQcm94eSIsInNyYyIsInJlcG9ydGVyIiwiY29uY3VycmVuY3kiLCJmaWx0ZXIiLCJ2aWRlbyIsInZpZGVvT3B0aW9ucyIsInZpZGVvRW5jb2RpbmdPcHRpb25zIiwic2NyZWVuc2hvdHMiLCJzY3JlZW5zaG90c09uRmFpbHMiLCJzY3JlZW5zaG90UGF0aFBhdHRlcm4iLCJzdGFydEFwcCIsImFwcCIsImFwcEluaXREZWxheSIsIm9uY2UiLCJoaWRlU3Bpbm5lciIsInJ1biIsInNob3dNZXNzYWdlT25FeGl0IiwiY2xvc2UiLCJleGl0IiwicnVuVGVzdHMiLCJwcm92aWRlck5hbWUiLCJicm93c2VyUHJvdmlkZXJQb29sIiwicmVxdWlyZSIsInByb3ZpZGVyIiwiZ2V0UHJvdmlkZXIiLCJHZW5lcmFsRXJyb3IiLCJNRVNTQUdFIiwiYnJvd3NlclByb3ZpZGVyTm90Rm91bmQiLCJpc011bHRpQnJvd3NlciIsImJyb3dzZXJOYW1lcyIsImdldEJyb3dzZXJMaXN0IiwiZGlzcG9zZSIsImNvbnNvbGUiLCJqb2luIiwibWFwIiwiYnJvd3Nlck5hbWUiLCJsaXN0QnJvd3NlcnMiLCJleGl0TWVzc2FnZVNob3duIiwiZXhpdGluZyIsImV4aXRIYW5kbGVyIiwidGVybWluYXRpb25MZXZlbCIsIndyaXRlIiwicHJvY2VzcyIsIm9uIiwiY29kZSIsInNldFRpbWVvdXQiLCJlcnJvciIsImVyciIsIm1lc3NhZ2UiLCJjb25zdHJ1Y3RvciIsIkFQSUVycm9yIiwiY29sb3JlZFN0YWNrIiwic3RhY2siLCJjaGFsayIsInJlZCIsImdyYXkiLCJ0ZXJtaW5hdGlvbkhhbmRsZXIiLCJUZXJtaW5hdGlvbkhhbmRsZXIiLCJURVJNSU5BVElPTl9MRVZFTF9JTkNSRUFTRURfRVZFTlQiLCJDbGlBcmd1bWVudFBhcnNlciIsInBhcnNlIiwiYXJndiIsImNsaSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OzsrQ0E0REEsV0FBeUJBLFNBQXpCLEVBQW9DO0FBQ2hDLGNBQU1DLE9BQW9CRCxVQUFVQyxJQUFwQztBQUNBLGNBQU1DLFFBQW9CRCxLQUFLRSxLQUFMLElBQWNGLEtBQUtFLEtBQUwsQ0FBVyxDQUFYLENBQXhDO0FBQ0EsY0FBTUMsUUFBb0JILEtBQUtFLEtBQUwsSUFBY0YsS0FBS0UsS0FBTCxDQUFXLENBQVgsQ0FBeEM7QUFDQSxjQUFNRSxRQUFvQkosS0FBS0ksS0FBL0I7QUFDQSxjQUFNQyxjQUFvQkwsS0FBS0ssV0FBL0I7O0FBRUFDLHNCQUFJQyxXQUFKOztBQUVBLGNBQU1DLFdBQWlCLE1BQU0sZ0JBQWVSLEtBQUtTLFFBQXBCLEVBQThCUixLQUE5QixFQUFxQ0UsS0FBckMsRUFBNENILEtBQUtVLEdBQWpELEVBQXNEVixLQUFLVyxHQUEzRCxDQUE3QjtBQUNBLGNBQU1DLGlCQUFpQixNQUFNLDZCQUFjSixRQUFkLEVBQXdCVCxVQUFVYyxXQUFsQyxFQUErQ2IsS0FBS2MsTUFBcEQsQ0FBN0I7QUFDQSxjQUFNQyxXQUFpQmhCLFVBQVVnQixRQUFWLENBQW1CQyxNQUFuQixDQUEwQkosY0FBMUIsQ0FBdkI7QUFDQSxjQUFNSyxTQUFpQmpCLEtBQUtrQixJQUFMLEdBQVlWLFNBQVNXLG9CQUFULEVBQVosR0FBOENYLFNBQVNZLFlBQVQsRUFBckU7O0FBRUEsWUFBSUMsU0FBUyxDQUFiOztBQUdBSixlQUFPSyxLQUFQLEdBQWUsSUFBZjs7QUFFQUwsZUFDS00sUUFETCxD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aWxlIjoiY2xpL2NsaS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBHZW5lcmFsRXJyb3IsIEFQSUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3J1bnRpbWUnO1xuaW1wb3J0IE1FU1NBR0UgZnJvbSAnLi4vZXJyb3JzL3J1bnRpbWUvbWVzc2FnZSc7XG5pbXBvcnQgQ2xpQXJndW1lbnRQYXJzZXIgZnJvbSAnLi9hcmd1bWVudC1wYXJzZXInO1xuaW1wb3J0IFRlcm1pbmF0aW9uSGFuZGxlciBmcm9tICcuL3Rlcm1pbmF0aW9uLWhhbmRsZXInO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZyc7XG5pbXBvcnQgcmVtb3Rlc1dpemFyZCBmcm9tICcuL3JlbW90ZXMtd2l6YXJkJztcbmltcG9ydCBjcmVhdGVUZXN0Q2FmZSBmcm9tICcuLi8nO1xuXG5sZXQgc2hvd01lc3NhZ2VPbkV4aXQgPSB0cnVlO1xubGV0IGV4aXRNZXNzYWdlU2hvd24gID0gZmFsc2U7XG5sZXQgZXhpdGluZyAgICAgICAgICAgPSBmYWxzZTtcblxuZnVuY3Rpb24gZXhpdEhhbmRsZXIgKHRlcm1pbmF0aW9uTGV2ZWwpIHtcbiAgICBpZiAoc2hvd01lc3NhZ2VPbkV4aXQgJiYgIWV4aXRNZXNzYWdlU2hvd24pIHtcbiAgICAgICAgZXhpdE1lc3NhZ2VTaG93biA9IHRydWU7XG5cbiAgICAgICAgbG9nLndyaXRlKCdTdG9wcGluZyBUZXN0Q2FmZS4uLicpO1xuXG4gICAgICAgIHByb2Nlc3Mub24oJ2V4aXQnLCAoKSA9PiBsb2cuaGlkZVNwaW5uZXIodHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmIChleGl0aW5nIHx8IHRlcm1pbmF0aW9uTGV2ZWwgPCAyKVxuICAgICAgICByZXR1cm47XG5cbiAgICBleGl0aW5nID0gdHJ1ZTtcblxuICAgIGV4aXQoMCk7XG59XG5cbmZ1bmN0aW9uIGV4aXQgKGNvZGUpIHtcbiAgICBsb2cuaGlkZVNwaW5uZXIodHJ1ZSk7XG5cbiAgICAvLyBOT1RFOiBnaXZlIGEgcHJvY2VzcyB0aW1lIHRvIGZsdXNoIHRoZSBvdXRwdXQuXG4gICAgLy8gSXQncyBuZWNlc3NhcnkgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gICAgc2V0VGltZW91dCgoKSA9PiBwcm9jZXNzLmV4aXQoY29kZSksIDApO1xufVxuXG5mdW5jdGlvbiBlcnJvciAoZXJyKSB7XG4gICAgbG9nLmhpZGVTcGlubmVyKCk7XG5cbiAgICBsZXQgbWVzc2FnZSA9IG51bGw7XG5cbiAgICAvLyBIQUNLOiB3b3JrYXJvdW5kIGZvciB0aGUgYGluc3RhbmNlb2ZgIHByb2JsZW1cbiAgICAvLyAoc2VlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMzODcwNjg0L3doeS1kb2VzbnQtaW5zdGFuY2VvZi13b3JrLW9uLWluc3RhbmNlcy1vZi1lcnJvci1zdWJjbGFzc2VzLXVuZGVyLWJhYmVsLW5vZGUpXG4gICAgaWYgKGVyci5jb25zdHJ1Y3RvciA9PT0gR2VuZXJhbEVycm9yKVxuICAgICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG5cbiAgICBlbHNlIGlmIChlcnIuY29uc3RydWN0b3IgPT09IEFQSUVycm9yKVxuICAgICAgICBtZXNzYWdlID0gZXJyLmNvbG9yZWRTdGFjaztcblxuICAgIGVsc2VcbiAgICAgICAgbWVzc2FnZSA9IGVyci5zdGFjaztcblxuICAgIGxvZy53cml0ZShjaGFsay5yZWQoJ0VSUk9SICcpICsgbWVzc2FnZSArICdcXG4nKTtcbiAgICBsb2cud3JpdGUoY2hhbGsuZ3JheSgnVHlwZSBcInRlc3RjYWZlIC1oXCIgZm9yIGhlbHAuJykpO1xuXG4gICAgZXhpdCgxKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuVGVzdHMgKGFyZ1BhcnNlcikge1xuICAgIGNvbnN0IG9wdHMgICAgICAgICAgICAgID0gYXJnUGFyc2VyLm9wdHM7XG4gICAgY29uc3QgcG9ydDEgICAgICAgICAgICAgPSBvcHRzLnBvcnRzICYmIG9wdHMucG9ydHNbMF07XG4gICAgY29uc3QgcG9ydDIgICAgICAgICAgICAgPSBvcHRzLnBvcnRzICYmIG9wdHMucG9ydHNbMV07XG4gICAgY29uc3QgcHJveHkgICAgICAgICAgICAgPSBvcHRzLnByb3h5O1xuICAgIGNvbnN0IHByb3h5QnlwYXNzICAgICAgID0gb3B0cy5wcm94eUJ5cGFzcztcblxuICAgIGxvZy5zaG93U3Bpbm5lcigpO1xuXG4gICAgY29uc3QgdGVzdENhZmUgICAgICAgPSBhd2FpdCBjcmVhdGVUZXN0Q2FmZShvcHRzLmhvc3RuYW1lLCBwb3J0MSwgcG9ydDIsIG9wdHMuc3NsLCBvcHRzLmRldik7XG4gICAgY29uc3QgcmVtb3RlQnJvd3NlcnMgPSBhd2FpdCByZW1vdGVzV2l6YXJkKHRlc3RDYWZlLCBhcmdQYXJzZXIucmVtb3RlQ291bnQsIG9wdHMucXJDb2RlKTtcbiAgICBjb25zdCBicm93c2VycyAgICAgICA9IGFyZ1BhcnNlci5icm93c2Vycy5jb25jYXQocmVtb3RlQnJvd3NlcnMpO1xuICAgIGNvbnN0IHJ1bm5lciAgICAgICAgID0gb3B0cy5saXZlID8gdGVzdENhZmUuY3JlYXRlTGl2ZU1vZGVSdW5uZXIoKSA6IHRlc3RDYWZlLmNyZWF0ZVJ1bm5lcigpO1xuXG4gICAgbGV0IGZhaWxlZCA9IDA7XG5cblxuICAgIHJ1bm5lci5pc0NsaSA9IHRydWU7XG5cbiAgICBydW5uZXJcbiAgICAgICAgLnVzZVByb3h5KHByb3h5LCBwcm94eUJ5cGFzcylcbiAgICAgICAgLnNyYyhhcmdQYXJzZXIuc3JjKVxuICAgICAgICAuYnJvd3NlcnMoYnJvd3NlcnMpXG4gICAgICAgIC5yZXBvcnRlcihhcmdQYXJzZXIub3B0cy5yZXBvcnRlcilcbiAgICAgICAgLmNvbmN1cnJlbmN5KGFyZ1BhcnNlci5vcHRzLmNvbmN1cnJlbmN5KVxuICAgICAgICAuZmlsdGVyKGFyZ1BhcnNlci5maWx0ZXIpXG4gICAgICAgIC52aWRlbyhvcHRzLnZpZGVvLCBvcHRzLnZpZGVvT3B0aW9ucywgb3B0cy52aWRlb0VuY29kaW5nT3B0aW9ucylcbiAgICAgICAgLnNjcmVlbnNob3RzKG9wdHMuc2NyZWVuc2hvdHMsIG9wdHMuc2NyZWVuc2hvdHNPbkZhaWxzLCBvcHRzLnNjcmVlbnNob3RQYXRoUGF0dGVybilcbiAgICAgICAgLnN0YXJ0QXBwKG9wdHMuYXBwLCBvcHRzLmFwcEluaXREZWxheSk7XG5cbiAgICBydW5uZXIub25jZSgnZG9uZS1ib290c3RyYXBwaW5nJywgKCkgPT4gbG9nLmhpZGVTcGlubmVyKCkpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZmFpbGVkID0gYXdhaXQgcnVubmVyLnJ1bihvcHRzKTtcbiAgICB9XG5cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgc2hvd01lc3NhZ2VPbkV4aXQgPSBmYWxzZTtcbiAgICAgICAgYXdhaXQgdGVzdENhZmUuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBleGl0KGZhaWxlZCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxpc3RCcm93c2VycyAocHJvdmlkZXJOYW1lID0gJ2xvY2FsbHktaW5zdGFsbGVkJykge1xuICAgIC8vIE5PVEU6IExvYWQgdGhlIHByb3ZpZGVyIHBvb2wgbGF6aWx5IHRvIHJlZHVjZSBzdGFydHVwIHRpbWVcbiAgICBjb25zdCBicm93c2VyUHJvdmlkZXJQb29sID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9wcm92aWRlci9wb29sJyk7XG5cbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGJyb3dzZXJQcm92aWRlclBvb2wuZ2V0UHJvdmlkZXIocHJvdmlkZXJOYW1lKTtcblxuICAgIGlmICghcHJvdmlkZXIpXG4gICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoTUVTU0FHRS5icm93c2VyUHJvdmlkZXJOb3RGb3VuZCwgcHJvdmlkZXJOYW1lKTtcblxuICAgIGlmIChwcm92aWRlci5pc011bHRpQnJvd3Nlcikge1xuICAgICAgICBjb25zdCBicm93c2VyTmFtZXMgPSBhd2FpdCBwcm92aWRlci5nZXRCcm93c2VyTGlzdCgpO1xuXG4gICAgICAgIGF3YWl0IGJyb3dzZXJQcm92aWRlclBvb2wuZGlzcG9zZSgpO1xuXG4gICAgICAgIGlmIChwcm92aWRlck5hbWUgPT09ICdsb2NhbGx5LWluc3RhbGxlZCcpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhicm93c2VyTmFtZXMuam9pbignXFxuJykpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhicm93c2VyTmFtZXMubWFwKGJyb3dzZXJOYW1lID0+IGBcIiR7cHJvdmlkZXJOYW1lfToke2Jyb3dzZXJOYW1lfVwiYCkuam9pbignXFxuJykpO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUubG9nKGBcIiR7cHJvdmlkZXJOYW1lfVwiYCk7XG5cbiAgICBleGl0KDApO1xufVxuXG4oYXN5bmMgZnVuY3Rpb24gY2xpICgpIHtcbiAgICBjb25zdCB0ZXJtaW5hdGlvbkhhbmRsZXIgPSBuZXcgVGVybWluYXRpb25IYW5kbGVyKCk7XG5cbiAgICB0ZXJtaW5hdGlvbkhhbmRsZXIub24oVGVybWluYXRpb25IYW5kbGVyLlRFUk1JTkFUSU9OX0xFVkVMX0lOQ1JFQVNFRF9FVkVOVCwgZXhpdEhhbmRsZXIpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXJnUGFyc2VyID0gbmV3IENsaUFyZ3VtZW50UGFyc2VyKCk7XG5cbiAgICAgICAgYXdhaXQgYXJnUGFyc2VyLnBhcnNlKHByb2Nlc3MuYXJndik7XG5cbiAgICAgICAgaWYgKGFyZ1BhcnNlci5vcHRzLmxpc3RCcm93c2VycylcbiAgICAgICAgICAgIGF3YWl0IGxpc3RCcm93c2VycyhhcmdQYXJzZXIub3B0cy5wcm92aWRlck5hbWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhd2FpdCBydW5UZXN0cyhhcmdQYXJzZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNob3dNZXNzYWdlT25FeGl0ID0gZmFsc2U7XG4gICAgICAgIGVycm9yKGVycik7XG4gICAgfVxufSkoKTtcblxuIl19
