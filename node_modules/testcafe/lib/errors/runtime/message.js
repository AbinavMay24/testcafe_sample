'use strict';

exports.__esModule = true;
// -------------------------------------------------------------
// WARNING: this file is used by both the client and the server.
// Do not use any browser or node-specific API!
// -------------------------------------------------------------

exports.default = {
                              cannotCreateMultipleLiveModeRunners: 'Cannot create multiple live mode runners.',
                              cannotRunLiveModeRunnerMultipleTimes: 'Cannot run a live mode runner multiple times.',
                              browserDisconnected: 'The {userAgent} browser disconnected. This problem may appear when a browser hangs or is closed, or due to network issues.',
                              cantRunAgainstDisconnectedBrowsers: 'The following browsers disconnected: {userAgents}. Tests will not be run.',
                              cantEstablishBrowserConnection: 'Unable to establish one or more of the specified browser connections. This can be caused by network issues or remote device failure.',
                              cantFindBrowser: 'Unable to find the browser. "{browser}" is not a browser alias or path to an executable file.',
                              browserProviderNotFound: 'The specified "{providerName}" browser provider was not found.',
                              browserNotSet: 'No browser selected to test against.',
                              testSourcesNotSet: 'No test file specified.',
                              noTestsToRun: 'No tests to run. Either the test files contain no tests or the filter function is too restrictive.',
                              cantFindReporterForAlias: 'The provided "{name}" reporter does not exist. Check that you have specified the report format correctly.',
                              multipleStdoutReporters: 'Multiple reporters attempting to write to stdout: "{reporters}". Only one reporter can write to stdout.',
                              optionValueIsNotValidRegExp: 'The "{optionName}" option value is not a valid regular expression.',
                              optionValueIsNotValidKeyValue: 'The "{optionName}" option value is not a valid key-value pair.',
                              invalidSpeedValue: 'Speed should be a number between 0.01 and 1.',
                              invalidConcurrencyFactor: 'The concurrency factor should be an integer greater or equal to 1.',
                              cannotDivideRemotesCountByConcurrency: 'The number of remote browsers should be divisible by the factor of concurrency.',
                              portsOptionRequiresTwoNumbers: 'The "--ports" option requires two numbers to be specified.',
                              portIsNotFree: 'The specified {portNum} port is already in use by another program.',
                              invalidHostname: 'The specified "{hostname}" hostname cannot be resolved to the current machine.',
                              cantFindSpecifiedTestSource: 'Cannot find a test source file at "{path}".',
                              clientFunctionCodeIsNotAFunction: '{#instantiationCallsiteName} code is expected to be specified as a function, but {type} was passed.',
                              selectorInitializedWithWrongType: '{#instantiationCallsiteName} is expected to be initialized with a function, CSS selector string, another Selector, node snapshot or a Promise returned by a Selector, but {type} was passed.',
                              clientFunctionCantResolveTestRun: "{#instantiationCallsiteName} cannot implicitly resolve the test run in context of which it should be executed. If you need to call {#instantiationCallsiteName} from the Node.js API callback, pass the test controller manually via {#instantiationCallsiteName}'s `.with({ boundTestRun: t })` method first. Note that you cannot execute {#instantiationCallsiteName} outside the test code.",
                              regeneratorInClientFunctionCode: `{#instantiationCallsiteName} code, arguments or dependencies cannot contain generators or "async/await" syntax (use Promises instead).`,
                              invalidClientFunctionTestRunBinding: 'The "boundTestRun" option value is expected to be a test controller.',
                              invalidValueType: '{smthg} is expected to be a {type}, but it was {actual}.',
                              unsupportedUrlProtocol: 'The specified "{url}" test page URL uses an unsupported {protocol}:// protocol. Only relative URLs or absolute URLs with http://, https:// and file:// protocols are supported.',
                              testControllerProxyCantResolveTestRun: `Cannot implicitly resolve the test run in the context of which the test controller action should be executed. Use test function's 't' argument instead.`,
                              timeLimitedPromiseTimeoutExpired: 'Timeout expired for a time limited promise',
                              cantUseScreenshotPathPatternWithoutBaseScreenshotPathSpecified: 'Unable to set the screenshot path pattern when screenshots are disabled. Specify the base path where screenshots are stored to enable them.',
                              cannotSetVideoOptionsWithoutBaseVideoPathSpecified: 'Unable to set video or encoding options when video recording is disabled. Specify the base path where video files are stored to enable recording.',
                              multipleAPIMethodCallForbidden: 'You cannot call the "{methodName}" method more than once. Pass an array of parameters to this method instead.',
                              invalidReporterOutput: "Specify a file name or a writable stream as the reporter's output target.",

                              cannotReadSSLCertFile: 'Unable to read the "{path}" file, specified by the "{option}" ssl option. Error details:\n' + '\n' + '{err}',

                              cannotPrepareTestsDueToError: 'Cannot prepare tests due to an error.\n' + '\n' + '{errMessage}',

                              cannotParseRawFile: 'Cannot parse a test source file in the raw format at "{path}" due to an error.\n' + '\n' + '{errMessage}',

                              testedAppFailedWithError: 'Tested app failed with an error:\n' + '\n' + '{errMessage}',

                              unableToOpenBrowser: 'Was unable to open the browser "{alias}" due to error.\n' + '\n' + '{errMessage}',

                              requestHookConfigureAPIError: 'There was an error while configuring the request hook:\n' + '\n' + '{requestHookName}: {errMsg}',

                              forbiddenCharatersInScreenshotPath: 'There are forbidden characters in the "{screenshotPath}" {screenshotPathType}:\n' + ' {forbiddenCharsDescription}',

                              cannotFindFFMPEG: 'Unable to locate the FFmpeg executable required to record videos. Do one of the following:\n' + '\n' + '* add the FFmpeg installation directory to the PATH environment variable,\n' + '* specify the path to the FFmpeg executable in the FFMPEG_PATH environment variable or the ffmpegPath video option,\n' + '* install the @ffmpeg-installer/ffmpeg package from npm.'
};
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9lcnJvcnMvcnVudGltZS9tZXNzYWdlLmpzIl0sIm5hbWVzIjpbImNhbm5vdENyZWF0ZU11bHRpcGxlTGl2ZU1vZGVSdW5uZXJzIiwiY2Fubm90UnVuTGl2ZU1vZGVSdW5uZXJNdWx0aXBsZVRpbWVzIiwiYnJvd3NlckRpc2Nvbm5lY3RlZCIsImNhbnRSdW5BZ2FpbnN0RGlzY29ubmVjdGVkQnJvd3NlcnMiLCJjYW50RXN0YWJsaXNoQnJvd3NlckNvbm5lY3Rpb24iLCJjYW50RmluZEJyb3dzZXIiLCJicm93c2VyUHJvdmlkZXJOb3RGb3VuZCIsImJyb3dzZXJOb3RTZXQiLCJ0ZXN0U291cmNlc05vdFNldCIsIm5vVGVzdHNUb1J1biIsImNhbnRGaW5kUmVwb3J0ZXJGb3JBbGlhcyIsIm11bHRpcGxlU3Rkb3V0UmVwb3J0ZXJzIiwib3B0aW9uVmFsdWVJc05vdFZhbGlkUmVnRXhwIiwib3B0aW9uVmFsdWVJc05vdFZhbGlkS2V5VmFsdWUiLCJpbnZhbGlkU3BlZWRWYWx1ZSIsImludmFsaWRDb25jdXJyZW5jeUZhY3RvciIsImNhbm5vdERpdmlkZVJlbW90ZXNDb3VudEJ5Q29uY3VycmVuY3kiLCJwb3J0c09wdGlvblJlcXVpcmVzVHdvTnVtYmVycyIsInBvcnRJc05vdEZyZWUiLCJpbnZhbGlkSG9zdG5hbWUiLCJjYW50RmluZFNwZWNpZmllZFRlc3RTb3VyY2UiLCJjbGllbnRGdW5jdGlvbkNvZGVJc05vdEFGdW5jdGlvbiIsInNlbGVjdG9ySW5pdGlhbGl6ZWRXaXRoV3JvbmdUeXBlIiwiY2xpZW50RnVuY3Rpb25DYW50UmVzb2x2ZVRlc3RSdW4iLCJyZWdlbmVyYXRvckluQ2xpZW50RnVuY3Rpb25Db2RlIiwiaW52YWxpZENsaWVudEZ1bmN0aW9uVGVzdFJ1bkJpbmRpbmciLCJpbnZhbGlkVmFsdWVUeXBlIiwidW5zdXBwb3J0ZWRVcmxQcm90b2NvbCIsInRlc3RDb250cm9sbGVyUHJveHlDYW50UmVzb2x2ZVRlc3RSdW4iLCJ0aW1lTGltaXRlZFByb21pc2VUaW1lb3V0RXhwaXJlZCIsImNhbnRVc2VTY3JlZW5zaG90UGF0aFBhdHRlcm5XaXRob3V0QmFzZVNjcmVlbnNob3RQYXRoU3BlY2lmaWVkIiwiY2Fubm90U2V0VmlkZW9PcHRpb25zV2l0aG91dEJhc2VWaWRlb1BhdGhTcGVjaWZpZWQiLCJtdWx0aXBsZUFQSU1ldGhvZENhbGxGb3JiaWRkZW4iLCJpbnZhbGlkUmVwb3J0ZXJPdXRwdXQiLCJjYW5ub3RSZWFkU1NMQ2VydEZpbGUiLCJjYW5ub3RQcmVwYXJlVGVzdHNEdWVUb0Vycm9yIiwiY2Fubm90UGFyc2VSYXdGaWxlIiwidGVzdGVkQXBwRmFpbGVkV2l0aEVycm9yIiwidW5hYmxlVG9PcGVuQnJvd3NlciIsInJlcXVlc3RIb29rQ29uZmlndXJlQVBJRXJyb3IiLCJmb3JiaWRkZW5DaGFyYXRlcnNJblNjcmVlbnNob3RQYXRoIiwiY2Fubm90RmluZEZGTVBFRyJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O2tCQUVlO0FBQ1hBLG1FQUFnRSwyQ0FEckQ7QUFFWEMsb0VBQWdFLCtDQUZyRDtBQUdYQyxtREFBZ0UsNEhBSHJEO0FBSVhDLGtFQUFnRSwyRUFKckQ7QUFLWEMsOERBQWdFLHNJQUxyRDtBQU1YQywrQ0FBZ0UsK0ZBTnJEO0FBT1hDLHVEQUFnRSxnRUFQckQ7QUFRWEMsNkNBQWdFLHNDQVJyRDtBQVNYQyxpREFBZ0UseUJBVHJEO0FBVVhDLDRDQUFnRSxvR0FWckQ7QUFXWEMsd0RBQWdFLDJHQVhyRDtBQVlYQyx1REFBZ0UseUdBWnJEO0FBYVhDLDJEQUFnRSxvRUFickQ7QUFjWEMsNkRBQWdFLGdFQWRyRDtBQWVYQyxpREFBZ0UsOENBZnJEO0FBZ0JYQyx3REFBZ0Usb0VBaEJyRDtBQWlCWEMscUVBQWdFLGlGQWpCckQ7QUFrQlhDLDZEQUFnRSw0REFsQnJEO0FBbUJYQyw2Q0FBZ0Usb0VBbkJyRDtBQW9CWEMsK0NBQWdFLGdGQXBCckQ7QUFxQlhDLDJEQUFnRSw2Q0FyQnJEO0FBc0JYQyxnRUFBZ0UscUdBdEJyRDtBQXVCWEMsZ0VBQWdFLDhMQXZCckQ7QUF3QlhDLGdFQUFnRSxpWUF4QnJEO0FBeUJYQywrREFBaUUsd0lBekJ0RDtBQTBCWEMsbUVBQWdFLHNFQTFCckQ7QUEyQlhDLGdEQUFnRSwwREEzQnJEO0FBNEJYQyxzREFBZ0UsaUxBNUJyRDtBQTZCWEMscUVBQWlFLHlKQTdCdEQ7QUE4QlhDLGdFQUFnRSw0Q0E5QnJEO0FBK0JYQyw4RkFBZ0UsNklBL0JyRDtBQWdDWEMsa0ZBQWdFLG1KQWhDckQ7QUFpQ1hDLDhEQUFnRSwrR0FqQ3JEO0FBa0NYQyxxREFBZ0UsMkVBbENyRDs7QUFvQ1hDLHFEQUF1QiwrRkFDQSxJQURBLEdBRUEsT0F0Q1o7O0FBd0NYQyw0REFBOEIsNENBQ0EsSUFEQSxHQUVBLGNBMUNuQjs7QUE0Q1hDLGtEQUFvQixxRkFDQSxJQURBLEdBRUEsY0E5Q1Q7O0FBZ0RYQyx3REFBMEIsdUNBQ0EsSUFEQSxHQUVBLGNBbERmOztBQW9EWEMsbURBQXFCLDZEQUNBLElBREEsR0FFQSxjQXREVjs7QUF3RFhDLDREQUE4Qiw2REFDQSxJQURBLEdBRUEsNkJBMURuQjs7QUE0RFhDLGtFQUFvQyxxRkFDQSw4QkE3RHpCOztBQStEWEMsZ0RBQWtCLGlHQUNBLElBREEsR0FFQSw2RUFGQSxHQUdBLHVIQUhBLEdBSUE7QUFuRVAsQyIsImZpbGUiOiJlcnJvcnMvcnVudGltZS9tZXNzYWdlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gV0FSTklORzogdGhpcyBmaWxlIGlzIHVzZWQgYnkgYm90aCB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyLlxuLy8gRG8gbm90IHVzZSBhbnkgYnJvd3NlciBvciBub2RlLXNwZWNpZmljIEFQSSFcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNhbm5vdENyZWF0ZU11bHRpcGxlTGl2ZU1vZGVSdW5uZXJzOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGNyZWF0ZSBtdWx0aXBsZSBsaXZlIG1vZGUgcnVubmVycy4nLFxuICAgIGNhbm5vdFJ1bkxpdmVNb2RlUnVubmVyTXVsdGlwbGVUaW1lczogICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IHJ1biBhIGxpdmUgbW9kZSBydW5uZXIgbXVsdGlwbGUgdGltZXMuJyxcbiAgICBicm93c2VyRGlzY29ubmVjdGVkOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSB7dXNlckFnZW50fSBicm93c2VyIGRpc2Nvbm5lY3RlZC4gVGhpcyBwcm9ibGVtIG1heSBhcHBlYXIgd2hlbiBhIGJyb3dzZXIgaGFuZ3Mgb3IgaXMgY2xvc2VkLCBvciBkdWUgdG8gbmV0d29yayBpc3N1ZXMuJyxcbiAgICBjYW50UnVuQWdhaW5zdERpc2Nvbm5lY3RlZEJyb3dzZXJzOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBmb2xsb3dpbmcgYnJvd3NlcnMgZGlzY29ubmVjdGVkOiB7dXNlckFnZW50c30uIFRlc3RzIHdpbGwgbm90IGJlIHJ1bi4nLFxuICAgIGNhbnRFc3RhYmxpc2hCcm93c2VyQ29ubmVjdGlvbjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVW5hYmxlIHRvIGVzdGFibGlzaCBvbmUgb3IgbW9yZSBvZiB0aGUgc3BlY2lmaWVkIGJyb3dzZXIgY29ubmVjdGlvbnMuIFRoaXMgY2FuIGJlIGNhdXNlZCBieSBuZXR3b3JrIGlzc3VlcyBvciByZW1vdGUgZGV2aWNlIGZhaWx1cmUuJyxcbiAgICBjYW50RmluZEJyb3dzZXI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VuYWJsZSB0byBmaW5kIHRoZSBicm93c2VyLiBcInticm93c2VyfVwiIGlzIG5vdCBhIGJyb3dzZXIgYWxpYXMgb3IgcGF0aCB0byBhbiBleGVjdXRhYmxlIGZpbGUuJyxcbiAgICBicm93c2VyUHJvdmlkZXJOb3RGb3VuZDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBzcGVjaWZpZWQgXCJ7cHJvdmlkZXJOYW1lfVwiIGJyb3dzZXIgcHJvdmlkZXIgd2FzIG5vdCBmb3VuZC4nLFxuICAgIGJyb3dzZXJOb3RTZXQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTm8gYnJvd3NlciBzZWxlY3RlZCB0byB0ZXN0IGFnYWluc3QuJyxcbiAgICB0ZXN0U291cmNlc05vdFNldDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ05vIHRlc3QgZmlsZSBzcGVjaWZpZWQuJyxcbiAgICBub1Rlc3RzVG9SdW46ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ05vIHRlc3RzIHRvIHJ1bi4gRWl0aGVyIHRoZSB0ZXN0IGZpbGVzIGNvbnRhaW4gbm8gdGVzdHMgb3IgdGhlIGZpbHRlciBmdW5jdGlvbiBpcyB0b28gcmVzdHJpY3RpdmUuJyxcbiAgICBjYW50RmluZFJlcG9ydGVyRm9yQWxpYXM6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBwcm92aWRlZCBcIntuYW1lfVwiIHJlcG9ydGVyIGRvZXMgbm90IGV4aXN0LiBDaGVjayB0aGF0IHlvdSBoYXZlIHNwZWNpZmllZCB0aGUgcmVwb3J0IGZvcm1hdCBjb3JyZWN0bHkuJyxcbiAgICBtdWx0aXBsZVN0ZG91dFJlcG9ydGVyczogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ011bHRpcGxlIHJlcG9ydGVycyBhdHRlbXB0aW5nIHRvIHdyaXRlIHRvIHN0ZG91dDogXCJ7cmVwb3J0ZXJzfVwiLiBPbmx5IG9uZSByZXBvcnRlciBjYW4gd3JpdGUgdG8gc3Rkb3V0LicsXG4gICAgb3B0aW9uVmFsdWVJc05vdFZhbGlkUmVnRXhwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgXCJ7b3B0aW9uTmFtZX1cIiBvcHRpb24gdmFsdWUgaXMgbm90IGEgdmFsaWQgcmVndWxhciBleHByZXNzaW9uLicsXG4gICAgb3B0aW9uVmFsdWVJc05vdFZhbGlkS2V5VmFsdWU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgXCJ7b3B0aW9uTmFtZX1cIiBvcHRpb24gdmFsdWUgaXMgbm90IGEgdmFsaWQga2V5LXZhbHVlIHBhaXIuJyxcbiAgICBpbnZhbGlkU3BlZWRWYWx1ZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1NwZWVkIHNob3VsZCBiZSBhIG51bWJlciBiZXR3ZWVuIDAuMDEgYW5kIDEuJyxcbiAgICBpbnZhbGlkQ29uY3VycmVuY3lGYWN0b3I6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBjb25jdXJyZW5jeSBmYWN0b3Igc2hvdWxkIGJlIGFuIGludGVnZXIgZ3JlYXRlciBvciBlcXVhbCB0byAxLicsXG4gICAgY2Fubm90RGl2aWRlUmVtb3Rlc0NvdW50QnlDb25jdXJyZW5jeTogICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgbnVtYmVyIG9mIHJlbW90ZSBicm93c2VycyBzaG91bGQgYmUgZGl2aXNpYmxlIGJ5IHRoZSBmYWN0b3Igb2YgY29uY3VycmVuY3kuJyxcbiAgICBwb3J0c09wdGlvblJlcXVpcmVzVHdvTnVtYmVyczogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBcIi0tcG9ydHNcIiBvcHRpb24gcmVxdWlyZXMgdHdvIG51bWJlcnMgdG8gYmUgc3BlY2lmaWVkLicsXG4gICAgcG9ydElzTm90RnJlZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgc3BlY2lmaWVkIHtwb3J0TnVtfSBwb3J0IGlzIGFscmVhZHkgaW4gdXNlIGJ5IGFub3RoZXIgcHJvZ3JhbS4nLFxuICAgIGludmFsaWRIb3N0bmFtZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHNwZWNpZmllZCBcIntob3N0bmFtZX1cIiBob3N0bmFtZSBjYW5ub3QgYmUgcmVzb2x2ZWQgdG8gdGhlIGN1cnJlbnQgbWFjaGluZS4nLFxuICAgIGNhbnRGaW5kU3BlY2lmaWVkVGVzdFNvdXJjZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGZpbmQgYSB0ZXN0IHNvdXJjZSBmaWxlIGF0IFwie3BhdGh9XCIuJyxcbiAgICBjbGllbnRGdW5jdGlvbkNvZGVJc05vdEFGdW5jdGlvbjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3sjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY29kZSBpcyBleHBlY3RlZCB0byBiZSBzcGVjaWZpZWQgYXMgYSBmdW5jdGlvbiwgYnV0IHt0eXBlfSB3YXMgcGFzc2VkLicsXG4gICAgc2VsZWN0b3JJbml0aWFsaXplZFdpdGhXcm9uZ1R5cGU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGlzIGV4cGVjdGVkIHRvIGJlIGluaXRpYWxpemVkIHdpdGggYSBmdW5jdGlvbiwgQ1NTIHNlbGVjdG9yIHN0cmluZywgYW5vdGhlciBTZWxlY3Rvciwgbm9kZSBzbmFwc2hvdCBvciBhIFByb21pc2UgcmV0dXJuZWQgYnkgYSBTZWxlY3RvciwgYnV0IHt0eXBlfSB3YXMgcGFzc2VkLicsXG4gICAgY2xpZW50RnVuY3Rpb25DYW50UmVzb2x2ZVRlc3RSdW46ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSBjYW5ub3QgaW1wbGljaXRseSByZXNvbHZlIHRoZSB0ZXN0IHJ1biBpbiBjb250ZXh0IG9mIHdoaWNoIGl0IHNob3VsZCBiZSBleGVjdXRlZC4gSWYgeW91IG5lZWQgdG8gY2FsbCB7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGZyb20gdGhlIE5vZGUuanMgQVBJIGNhbGxiYWNrLCBwYXNzIHRoZSB0ZXN0IGNvbnRyb2xsZXIgbWFudWFsbHkgdmlhIHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0ncyBgLndpdGgoeyBib3VuZFRlc3RSdW46IHQgfSlgIG1ldGhvZCBmaXJzdC4gTm90ZSB0aGF0IHlvdSBjYW5ub3QgZXhlY3V0ZSB7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IG91dHNpZGUgdGhlIHRlc3QgY29kZS5cIixcbiAgICByZWdlbmVyYXRvckluQ2xpZW50RnVuY3Rpb25Db2RlOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY29kZSwgYXJndW1lbnRzIG9yIGRlcGVuZGVuY2llcyBjYW5ub3QgY29udGFpbiBnZW5lcmF0b3JzIG9yIFwiYXN5bmMvYXdhaXRcIiBzeW50YXggKHVzZSBQcm9taXNlcyBpbnN0ZWFkKS5gLFxuICAgIGludmFsaWRDbGllbnRGdW5jdGlvblRlc3RSdW5CaW5kaW5nOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwiYm91bmRUZXN0UnVuXCIgb3B0aW9uIHZhbHVlIGlzIGV4cGVjdGVkIHRvIGJlIGEgdGVzdCBjb250cm9sbGVyLicsXG4gICAgaW52YWxpZFZhbHVlVHlwZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7c210aGd9IGlzIGV4cGVjdGVkIHRvIGJlIGEge3R5cGV9LCBidXQgaXQgd2FzIHthY3R1YWx9LicsXG4gICAgdW5zdXBwb3J0ZWRVcmxQcm90b2NvbDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgc3BlY2lmaWVkIFwie3VybH1cIiB0ZXN0IHBhZ2UgVVJMIHVzZXMgYW4gdW5zdXBwb3J0ZWQge3Byb3RvY29sfTovLyBwcm90b2NvbC4gT25seSByZWxhdGl2ZSBVUkxzIG9yIGFic29sdXRlIFVSTHMgd2l0aCBodHRwOi8vLCBodHRwczovLyBhbmQgZmlsZTovLyBwcm90b2NvbHMgYXJlIHN1cHBvcnRlZC4nLFxuICAgIHRlc3RDb250cm9sbGVyUHJveHlDYW50UmVzb2x2ZVRlc3RSdW46ICAgICAgICAgICAgICAgICAgICAgICAgICBgQ2Fubm90IGltcGxpY2l0bHkgcmVzb2x2ZSB0aGUgdGVzdCBydW4gaW4gdGhlIGNvbnRleHQgb2Ygd2hpY2ggdGhlIHRlc3QgY29udHJvbGxlciBhY3Rpb24gc2hvdWxkIGJlIGV4ZWN1dGVkLiBVc2UgdGVzdCBmdW5jdGlvbidzICd0JyBhcmd1bWVudCBpbnN0ZWFkLmAsXG4gICAgdGltZUxpbWl0ZWRQcm9taXNlVGltZW91dEV4cGlyZWQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaW1lb3V0IGV4cGlyZWQgZm9yIGEgdGltZSBsaW1pdGVkIHByb21pc2UnLFxuICAgIGNhbnRVc2VTY3JlZW5zaG90UGF0aFBhdHRlcm5XaXRob3V0QmFzZVNjcmVlbnNob3RQYXRoU3BlY2lmaWVkOiAnVW5hYmxlIHRvIHNldCB0aGUgc2NyZWVuc2hvdCBwYXRoIHBhdHRlcm4gd2hlbiBzY3JlZW5zaG90cyBhcmUgZGlzYWJsZWQuIFNwZWNpZnkgdGhlIGJhc2UgcGF0aCB3aGVyZSBzY3JlZW5zaG90cyBhcmUgc3RvcmVkIHRvIGVuYWJsZSB0aGVtLicsXG4gICAgY2Fubm90U2V0VmlkZW9PcHRpb25zV2l0aG91dEJhc2VWaWRlb1BhdGhTcGVjaWZpZWQ6ICAgICAgICAgICAgICdVbmFibGUgdG8gc2V0IHZpZGVvIG9yIGVuY29kaW5nIG9wdGlvbnMgd2hlbiB2aWRlbyByZWNvcmRpbmcgaXMgZGlzYWJsZWQuIFNwZWNpZnkgdGhlIGJhc2UgcGF0aCB3aGVyZSB2aWRlbyBmaWxlcyBhcmUgc3RvcmVkIHRvIGVuYWJsZSByZWNvcmRpbmcuJyxcbiAgICBtdWx0aXBsZUFQSU1ldGhvZENhbGxGb3JiaWRkZW46ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1lvdSBjYW5ub3QgY2FsbCB0aGUgXCJ7bWV0aG9kTmFtZX1cIiBtZXRob2QgbW9yZSB0aGFuIG9uY2UuIFBhc3MgYW4gYXJyYXkgb2YgcGFyYW1ldGVycyB0byB0aGlzIG1ldGhvZCBpbnN0ZWFkLicsXG4gICAgaW52YWxpZFJlcG9ydGVyT3V0cHV0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU3BlY2lmeSBhIGZpbGUgbmFtZSBvciBhIHdyaXRhYmxlIHN0cmVhbSBhcyB0aGUgcmVwb3J0ZXIncyBvdXRwdXQgdGFyZ2V0LlwiLFxuXG4gICAgY2Fubm90UmVhZFNTTENlcnRGaWxlOiAnVW5hYmxlIHRvIHJlYWQgdGhlIFwie3BhdGh9XCIgZmlsZSwgc3BlY2lmaWVkIGJ5IHRoZSBcIntvcHRpb259XCIgc3NsIG9wdGlvbi4gRXJyb3IgZGV0YWlsczpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICd7ZXJyfScsXG5cbiAgICBjYW5ub3RQcmVwYXJlVGVzdHNEdWVUb0Vycm9yOiAnQ2Fubm90IHByZXBhcmUgdGVzdHMgZHVlIHRvIGFuIGVycm9yLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIGNhbm5vdFBhcnNlUmF3RmlsZTogJ0Nhbm5vdCBwYXJzZSBhIHRlc3Qgc291cmNlIGZpbGUgaW4gdGhlIHJhdyBmb3JtYXQgYXQgXCJ7cGF0aH1cIiBkdWUgdG8gYW4gZXJyb3IuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIHRlc3RlZEFwcEZhaWxlZFdpdGhFcnJvcjogJ1Rlc3RlZCBhcHAgZmFpbGVkIHdpdGggYW4gZXJyb3I6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIHVuYWJsZVRvT3BlbkJyb3dzZXI6ICdXYXMgdW5hYmxlIHRvIG9wZW4gdGhlIGJyb3dzZXIgXCJ7YWxpYXN9XCIgZHVlIHRvIGVycm9yLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIHJlcXVlc3RIb29rQ29uZmlndXJlQVBJRXJyb3I6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY29uZmlndXJpbmcgdGhlIHJlcXVlc3QgaG9vazpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tyZXF1ZXN0SG9va05hbWV9OiB7ZXJyTXNnfScsXG5cbiAgICBmb3JiaWRkZW5DaGFyYXRlcnNJblNjcmVlbnNob3RQYXRoOiAnVGhlcmUgYXJlIGZvcmJpZGRlbiBjaGFyYWN0ZXJzIGluIHRoZSBcIntzY3JlZW5zaG90UGF0aH1cIiB7c2NyZWVuc2hvdFBhdGhUeXBlfTpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHtmb3JiaWRkZW5DaGFyc0Rlc2NyaXB0aW9ufScsXG5cbiAgICBjYW5ub3RGaW5kRkZNUEVHOiAnVW5hYmxlIHRvIGxvY2F0ZSB0aGUgRkZtcGVnIGV4ZWN1dGFibGUgcmVxdWlyZWQgdG8gcmVjb3JkIHZpZGVvcy4gRG8gb25lIG9mIHRoZSBmb2xsb3dpbmc6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICcqIGFkZCB0aGUgRkZtcGVnIGluc3RhbGxhdGlvbiBkaXJlY3RvcnkgdG8gdGhlIFBBVEggZW52aXJvbm1lbnQgdmFyaWFibGUsXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgJyogc3BlY2lmeSB0aGUgcGF0aCB0byB0aGUgRkZtcGVnIGV4ZWN1dGFibGUgaW4gdGhlIEZGTVBFR19QQVRIIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIHRoZSBmZm1wZWdQYXRoIHZpZGVvIG9wdGlvbixcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAnKiBpbnN0YWxsIHRoZSBAZmZtcGVnLWluc3RhbGxlci9mZm1wZWcgcGFja2FnZSBmcm9tIG5wbS4nLFxufTtcbiJdfQ==
